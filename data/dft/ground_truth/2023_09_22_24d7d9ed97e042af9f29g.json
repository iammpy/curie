{"code": "import numpy as np\nfrom ase import Atoms\nfrom ase.calculators.gaussian import Gaussian\nfrom ase.optimize import BFGS\nfrom pydantic import BaseModel\n\nfrom annotations.models.GaussianParameters import GaussianParameters\n\n# Functions Code\n\n\n\ndef gaussian_relaxation(atoms: Atoms, parameters: GaussianParameters) -> Atoms:\n    gaussian_keys = [\n        \"label\",\n        \"output_type\",\n        \"method\",\n        \"xc\",\n        \"basis\",\n        \"fitting_basis\",\n        \"charge\",\n        \"mult\",\n        \"basisfile\",\n        \"basis_set\",\n        \"extra\",\n        \"addsec\",\n        \"ioplist\",\n        \"spinlist\",\n        \"zefflist\",\n        \"qmomlist\",\n        \"nmagmlist\",\n        \"znuclist\",\n        \"radnuclearlist\",\n    ]\n    gaussian_dict = {\n        k: v\n        for k, v in parameters.dict(exclude_none=True).items()\n        if k in gaussian_keys\n    }\n    calc = Gaussian(**gaussian_dict)\n    atoms.set_calculator(calc)\n    dyn = BFGS(atoms)\n    dyn.run(parameters.fmax)\n\n    return atoms\n\n\ndef boltzmann_population(energies: list[float]) -> list[float]:\n    k = 1.380649e-23  # Boltzmann constant in J/K\n    T = 298.15\n    energies_array = np.array(energies)\n    Z = np.sum(np.exp(-energies_array / (k * T)))\n    populations = np.exp(-energies_array / (k * T)) / Z\n\n    return list(populations)\n\n\ndef structure_generation_eeaca6a4a47ddb9f7dea3fe0b43aa1ad520d159e() -> Atoms:\n    pass\n\n\n# Inputs Code\n\n\n\nclass GaussianParameters(BaseModel):\n    label: str | None = None\n    output_type: str | None = None\n    method: str | None = None\n    xc: str | None = None\n    basis: str | None = None\n    fitting_basis: str | None = None\n    charge: int | None = None\n    mult: int | None = None\n    basisfile: str | None = None\n    basis_set: str | None = None\n    extra: str | None = None\n    addsec: str | None = None\n    ioplist: list | None = None\n    spinlist: list | None = None\n    zefflist: list | None = None\n    qmomlist: list | None = None\n    nmagmlist: list | None = None\n    znuclist: list | None = None\n    radnuclearlist: list | None = None\n    fmax: float | None = 1e-5\n\ngaussian_parameters_2 = GaussianParameters.parse_raw('{\"label\": NaN, \"output_type\": NaN, \"method\": NaN, \"xc\": \"B3LYP\", \"basis\": \"Def2TZVP\", \"fitting_basis\": NaN, \"charge\": NaN, \"mult\": NaN, \"basisfile\": NaN, \"basis_set\": NaN, \"extra\": \"['EmpiricalDispersion=GD3', 'SCRF=20000']\", \"addsec\": NaN, \"ioplist\": NaN, \"spinlist\": NaN, \"zefflist\": NaN, \"qmomlist\": NaN, \"nmagmlist\": NaN, \"znuclist\": NaN, \"radnuclearlist\": NaN, \"fmax\": NaN}')\n\n# Execution Code\n\nstructure_list = structure_generation_eeaca6a4a47ddb9f7dea3fe0b43aa1ad520d159e()\nrelaxed_structure_list = []\nfor structure_list_entry in structure_list:\n    relaxed_structure_list_entry = gaussian_relaxation(structure_list_entry, gaussian_parameters_2)\n    relaxed_structure_list.append(relaxed_structure_list_entry)\n\nconformer_populations = []\nfor relaxed_structure_list_entry in relaxed_structure_list:\n    conformer_populations_entry = boltzmann_population(relaxed_structure_list_entry)\n    conformer_populations.append(conformer_populations_entry)\n\n", "graph_as_text": "[{\"description\": \"returns a random sampling of structures from the COLMAR database\", \"function_id\": \"process_54\", \"function_name\": \"structure_generation_eeaca6a4a47ddb9f7dea3fe0b43aa1ad520d159e\", \"input_types\": [], \"inputs\": [], \"output_types\": [\"list[Atoms]\"], \"outputs\": [\"structure_list\"], \"process_type\": \"structure_generation\"}, {\"description\": \"runs a dft geometric relaxation using the Gaussian code in ase and returns the atoms object using two inputs: the calculator parameters specified in a pydantic basemodel called GaussianParameters and an input ase atoms object\", \"function_id\": \"process_55\", \"function_name\": \"gaussian_relaxation\", \"input_types\": [\"list[Atoms]\", \"GaussianParameters\"], \"inputs\": [\"structure_list\", \"gaussian_parameters_2\"], \"output_types\": [\"list[Atoms]\"], \"outputs\": [\"relaxed_structure_list\"], \"process_type\": \"dft\"}, {\"description\": \"takes in a list of energies and returns the population of each corresponding state using the boltzmann distribution and a temperature of 298.15K\", \"function_id\": \"process_56\", \"function_name\": \"boltzmann_population\", \"input_types\": [\"list[Atoms]\"], \"inputs\": [\"relaxed_structure_list\"], \"output_types\": [\"list[float]\"], \"outputs\": [\"conformer_populations\"], \"process_type\": \"analysis\"}]", "no_header_code": "import numpy as np\nfrom ase import Atoms\nfrom ase.calculators.gaussian import Gaussian\nfrom ase.optimize import BFGS\nfrom pydantic import BaseModel\n\nfrom annotations.models.GaussianParameters import GaussianParameters\n\n# Functions Code\n\n\n\ndef boltzmann_population(energies: list[float]) -> list[float]:\n    k = 1.380649e-23  # Boltzmann constant in J/K\n    T = 298.15\n    energies_array = np.array(energies)\n    Z = np.sum(np.exp(-energies_array / (k * T)))\n    populations = np.exp(-energies_array / (k * T)) / Z\n\n    return list(populations)\n\n\ndef gaussian_relaxation(atoms: Atoms, parameters: GaussianParameters) -> Atoms:\n    gaussian_keys = [\n        \"label\",\n        \"output_type\",\n        \"method\",\n        \"xc\",\n        \"basis\",\n        \"fitting_basis\",\n        \"charge\",\n        \"mult\",\n        \"basisfile\",\n        \"basis_set\",\n        \"extra\",\n        \"addsec\",\n        \"ioplist\",\n        \"spinlist\",\n        \"zefflist\",\n        \"qmomlist\",\n        \"nmagmlist\",\n        \"znuclist\",\n        \"radnuclearlist\",\n    ]\n    gaussian_dict = {\n        k: v\n        for k, v in parameters.dict(exclude_none=True).items()\n        if k in gaussian_keys\n    }\n    calc = Gaussian(**gaussian_dict)\n    atoms.set_calculator(calc)\n    dyn = BFGS(atoms)\n    dyn.run(parameters.fmax)\n\n    return atoms\n\n\ndef structure_generation_eeaca6a4a47ddb9f7dea3fe0b43aa1ad520d159e() -> Atoms:\n    pass\n\n\n# Inputs Code\n\n\n\nclass GaussianParameters(BaseModel):\n    label: str | None = None\n    output_type: str | None = None\n    method: str | None = None\n    xc: str | None = None\n    basis: str | None = None\n    fitting_basis: str | None = None\n    charge: int | None = None\n    mult: int | None = None\n    basisfile: str | None = None\n    basis_set: str | None = None\n    extra: str | None = None\n    addsec: str | None = None\n    ioplist: list | None = None\n    spinlist: list | None = None\n    zefflist: list | None = None\n    qmomlist: list | None = None\n    nmagmlist: list | None = None\n    znuclist: list | None = None\n    radnuclearlist: list | None = None\n    fmax: float | None = 1e-5\n\ngaussian_parameters_2 = GaussianParameters.parse_raw('{\"label\": NaN, \"output_type\": NaN, \"method\": NaN, \"xc\": \"B3LYP\", \"basis\": \"Def2TZVP\", \"fitting_basis\": NaN, \"charge\": NaN, \"mult\": NaN, \"basisfile\": NaN, \"basis_set\": NaN, \"extra\": \"['EmpiricalDispersion=GD3', 'SCRF=20000']\", \"addsec\": NaN, \"ioplist\": NaN, \"spinlist\": NaN, \"zefflist\": NaN, \"qmomlist\": NaN, \"nmagmlist\": NaN, \"znuclist\": NaN, \"radnuclearlist\": NaN, \"fmax\": NaN}')\n\n# Execution Code\n\nstructure_list = structure_generation_eeaca6a4a47ddb9f7dea3fe0b43aa1ad520d159e()\nrelaxed_structure_list = []\nfor structure_list_entry in structure_list:\n    relaxed_structure_list_entry = gaussian_relaxation(structure_list_entry, gaussian_parameters_2)\n    relaxed_structure_list.append(relaxed_structure_list_entry)\n\nconformer_populations = []\nfor relaxed_structure_list_entry in relaxed_structure_list:\n    conformer_populations_entry = boltzmann_population(relaxed_structure_list_entry)\n    conformer_populations.append(conformer_populations_entry)\n\n", "record_id": "2023_09_22_24d7d9ed97e042af9f29g"}